🧱 SKELETON: Base Classes
class GameObject {
  constructor() { this.active = true; }
  update() {}
  destroy() { this.active = false; }
}

Line	Explanation
class GameObject {	Defines the base "blueprint" all game things inherit from.
constructor() { this.active = true; }	When created, every object starts as “active” (alive) in the game.
update() {}	Placeholder method. Children override this with their own logic.
destroy() { this.active = false; }	Deactivates the object so it can be removed from the game later.

So far — every “thing” in the game at least exists, can update, and can die.

class RenderableObject extends GameObject {
  constructor(el) { super(); this.el = el; }
  render(parent) {
    if (!this.el.parentNode) parent.appendChild(this.el);
  }
  destroy() {
    if (this.el.parentNode) this.el.remove();
    super.destroy();
  }
}

Line	Explanation
extends GameObject	Inherits from GameObject. Adds visual (“renderable”) properties.
constructor(el)	Takes a DOM element to represent itself visually.
super(); this.el = el;	Calls parent constructor, then stores that element.
render(parent)	If this object isn’t already in the DOM, add it to the given parent (like #game).
destroy()	Removes its element from the DOM before marking inactive.

Now we have visible entities that appear/disappear properly.

class PhysicalObject extends RenderableObject {
  constructor(el) {
    super(el);
    this.x = 0; this.y = 0;
    this.vx = 0; this.vy = 0;
  }
  physics(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.el.style.transform = `translate(${this.x}px, ${this.y}px)`;
  }
  update(dt) { this.physics(dt); }
}

Line	Explanation
extends RenderableObject	Adds movement and position logic.
this.x, this.y	Position on screen (in pixels).
this.vx, this.vy	Velocity (how much it moves each frame).
physics(dt)	Applies motion math: new position = old position + velocity × time.
this.el.style.transform = ...	Moves the element visually using CSS transform.
update(dt)	Every frame, update physics.

This makes objects move automatically when given velocity.

🧠 BRAIN: Game Manager
class GameManager {
  constructor(root) {
    this.root = root;
    this.objects = [];
    this.input = new Input();
    this.score = 0;

    this.scoreEl = document.createElement("div");
    this.scoreEl.id = "score";
    root.appendChild(this.scoreEl);
  }

Line	Explanation
constructor(root)	Takes the main DOM container (like #game).
this.root	Keeps reference to the game area element.
this.objects = []	Array holding all entities (player, fruits, bombs, etc.).
this.input = new Input();	Creates a keyboard listener instance.
this.score = 0;	Initializes score tracker.
this.scoreEl = ...	Creates a DOM element to show the score.
root.appendChild(this.scoreEl);	Displays it in the game.
  add(obj) {
    this.objects.push(obj);
    obj.render(this.root);
  }


Adds a new game object to the list and immediately appends its element to the DOM.

  update(dt) {
    this.objects.forEach(o => o.active && o.update(dt));
    this.objects = this.objects.filter(o => o.active);
    this.scoreEl.textContent = `Score: ${this.score}`;
  }

Line	Explanation
forEach(o => o.active && o.update(dt))	Calls update() only on alive objects.
filter(o => o.active)	Removes dead objects from the list.
scoreEl.textContent = ...	Updates the score display every frame.
  loop() {
    this.update(1);
    requestAnimationFrame(() => this.loop());
  }
}

Line	Explanation
loop()	The “heartbeat” of the game. Runs once per frame.
update(1)	Updates all objects (with a simple deltaTime of 1 for now).
requestAnimationFrame(...)	Schedules the next heartbeat on the next browser frame.
💓 HEART: Input System
class Input {
  constructor() {
    this.keys = {};
    document.addEventListener("keydown", e => this.keys[e.key] = true);
    document.addEventListener("keyup", e => this.keys[e.key] = false);
  }
  down(key) { return !!this.keys[key]; }
}

Line	Explanation
this.keys = {}	Keeps track of which keys are pressed.
keydown / keyup events	Set and clear those keys in the dictionary.
down(key)	Returns true if that key is currently pressed.

Now you can just ask: if (input.down("ArrowLeft")) inside your player logic.

💪 MUSCLES: Entities
Player
class Player extends PhysicalObject {
  constructor() {
    const el = document.createElement("div");
    el.className = "player";
    super(el);
    this.speed = 5;
    this.setPosition(170, 450);
  }

Line	Explanation
class Player extends PhysicalObject	Inherits movement + visuals.
createElement("div")	Makes a DOM element for the player.
.className = "player"	Applies the player CSS style.
super(el)	Passes the element to the parent constructors.
this.speed = 5	Movement speed (pixels per frame).
setPosition(170, 450)	Starting position near bottom center.
  setPosition(x, y) {
    this.x = x; this.y = y;
    this.el.style.transform = `translate(${x}px, ${y}px)`;
  }

  move(input) {
    if (input.down("ArrowLeft") && this.x > 0) this.x -= this.speed;
    if (input.down("ArrowRight") && this.x < 340) this.x += this.speed;
    this.el.style.transform = `translate(${this.x}px, ${this.y}px)`;
  }
}

Line	Explanation
setPosition	Sets x/y manually and moves the element.
move(input)	Checks keys and moves left/right.
this.x > 0 / < 340	Keeps player within screen boundaries.
transform	Updates the visual position instantly.
Fruit
class Fruit extends PhysicalObject {
  constructor(x) {
    const el = document.createElement("div");
    el.className = "fruit";
    super(el);
    this.x = x;
    this.y = 0;
    this.vy = 2 + Math.random() * 2;
  }

  update(dt) {
    super.update(dt);
    if (this.y > 500) this.destroy();
  }
}

Line	Explanation
className = "fruit"	Applies fruit image style.
this.x = x	Spawn position.
this.vy	Random downward speed.
update(dt)	Moves down each frame; removes when offscreen.
Bomb
class Bomb extends PhysicalObject {
  constructor(x) {
    const el = document.createElement("div");
    el.className = "bomb";
    super(el);
    this.x = x;
    this.y = 0;
    this.vy = 3 + Math.random() * 2;
  }

  update(dt) {
    super.update(dt);
    if (this.y > 500) this.destroy();
  }
}


Same logic as fruit but faster and dangerous.

🧬 UTILITY: Collision Check
function isColliding(a, b) {
  const r1 = a.el.getBoundingClientRect();
  const r2 = b.el.getBoundingClientRect();
  return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
}

Line	Explanation
getBoundingClientRect()	Gets screen rectangles for two objects.
The return line	Standard AABB (Axis-Aligned Bounding Box) overlap test — returns true if the boxes touch or overlap.
🕹️ FINAL: Game Setup + Loop
const gameRoot = document.getElementById("game");
const game = new GameManager(gameRoot);

Explanation
Finds the #game div in HTML and makes a GameManager for it.
const player = new Player();
game.add(player);

Explanation
Creates and adds the player to the game.
setInterval(() => {
  const x = Math.random() * 370;
  if (Math.random() < 0.8) {
    game.add(new Fruit(x));
  } else {
    game.add(new Bomb(x));
  }
}, 1000);

Explanation
Every 1000 ms (1 s), spawn a new object.
80 % chance = fruit, 20 % = bomb.
x gives random horizontal spawn position.
function loop() {
  player.move(game.input);
  for (const obj of game.objects) {
    if (obj !== player && isColliding(player, obj)) {
      if (obj instanceof Fruit) {
        game.score += 1;
      } else if (obj instanceof Bomb) {
        game.score -= 2;
      }
      obj.destroy();
    }
  }
  game.update(1);
  requestAnimationFrame(loop);
}

loop();

Section	Explanation
player.move(game.input)	Reads arrow key input each frame.
for (const obj ...)	Checks every object for collisions with the player.
instanceof Fruit	If it’s a fruit, increase score.
instanceof Bomb	If it’s a bomb, decrease score.
obj.destroy()	Removes the caught or exploded item.
game.update(1)	Updates all objects + score display.
requestAnimationFrame(loop)	Runs the next frame (the “heartbeat”).
loop();	Starts the cycle.
🎯 Result Summary

Skeleton (GameObject hierarchy): gives everything structure.

Brain/Heart (GameManager, loop()): keeps the world alive and updated.

Muscles (entity classes): define movement & behavior.

Skin (CSS/HTML): gives everything visible form.

Blood flow (Input, collisions): connects player and world.